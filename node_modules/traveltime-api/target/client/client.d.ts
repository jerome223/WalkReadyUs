import { MapInfoResponse, GeocodingResponse, GeocodingSearchRequest, RoutesRequest, RoutesResponse, SupportedLocationsResponse, SupportedLocationsRequest, TimeMapRequest, TimeMapResponse, TimeFilterRequest, TimeFilterResponse, TimeFilterFastRequest, TimeFilterFastResponse, TimeFilterPostcodesRequest, TimeFilterPostcodesResponse, TimeFilterPostcodeDistrictsRequest, TimeFilterPostcodeDistrictsResponse, TimeFilterPostcodeSectorsRequest, TimeFilterPostcodeSectorsResponse, TimeMapFastRequest, Coords, Credentials, TimeMapSimple, TimeMapFastSimple, TimeFilterSimple, TimeFilterFastSimple, RoutesSimple, BatchResponse, DistanceMapRequest, DistanceMapResponseType, DistanceMapResponse, DistanceMapSimple } from '../types';
import { TimeMapFastResponseType, TimeMapResponseType } from '../types/timeMapResponse';
import { RateLimitSettings } from './rateLimiter';
export declare class TravelTimeClient {
    private apiKey;
    private applicationId;
    private axiosInstance;
    private rateLimiter;
    constructor(credentials: Credentials, parameters?: {
        baseURL?: string;
        rateLimitSettings?: Partial<RateLimitSettings>;
    });
    private request;
    private batch;
    distanceMap(body: DistanceMapRequest): Promise<DistanceMapResponse>;
    distanceMap<T extends keyof DistanceMapResponseType>(body: DistanceMapRequest, format: T): Promise<DistanceMapResponseType[T]>;
    distanceMapBatch(bodies: DistanceMapRequest[]): Promise<BatchResponse<Awaited<DistanceMapResponse>>[]>;
    distanceMapBatch<T extends keyof DistanceMapResponseType>(bodies: DistanceMapRequest[], format: T): Promise<BatchResponse<Awaited<DistanceMapResponseType[T]>>[]>;
    /**
     * Simplified version of distanceMap.
     * Allows you to pass multiple coordinates with same params for shape to be made.
     * @param {DistanceMapSimple} body Simplified DistanceMapRequest. Default search type is `departure`.
     * @param {keyof DistanceMapResponseType} [format] Specify in which format response should be returned.
     */
    distanceMapSimple(body: DistanceMapSimple): Promise<TimeMapResponse>;
    distanceMapSimple<T extends keyof DistanceMapResponseType>(body: DistanceMapSimple, format: T): Promise<DistanceMapResponseType[T]>;
    geocoding(query: string, req?: GeocodingSearchRequest): Promise<GeocodingResponse>;
    geocodingBatch: (requests: Coords[], req?: GeocodingSearchRequest) => Promise<BatchResponse<GeocodingResponse>[]>;
    geocodingReverse(coords: Coords, acceptLanguage?: string): Promise<GeocodingResponse>;
    geocodingReverseBatch: (requests: Coords[], acceptLanguage?: string) => Promise<BatchResponse<GeocodingResponse>[]>;
    mapInfo: () => Promise<MapInfoResponse>;
    routes: (body: RoutesRequest) => Promise<RoutesResponse>;
    routesBatch: (requests: RoutesRequest[]) => Promise<BatchResponse<RoutesResponse>[]>;
    /**
     * Simplified version of routes.
     * Allows you to pass multiple coordinates with same params for routes to be made.
     * @param {RoutesSimple} body Simplified RoutesRequest type. Default search type is `departure`.
     */
    routesSimple: (body: RoutesSimple) => Promise<RoutesResponse>;
    supportedLocations: (body: SupportedLocationsRequest) => Promise<SupportedLocationsResponse>;
    timeFilter: (body: TimeFilterRequest) => Promise<TimeFilterResponse>;
    timeFilterBatch: (requests: TimeFilterRequest[]) => Promise<BatchResponse<TimeFilterResponse>[]>;
    /**
     * Simplified version of timeFilter.
     * Allows you to pass multiple coordinates with same params for matrixes to be made.
     * @param {TimeFilterSimple} body Simplified TimeFilterRequest type. Default search type is `departure`.
     */
    timeFilterSimple: (body: TimeFilterSimple) => Promise<TimeFilterResponse>;
    /**
     * Generates a data frame (full matrix).
     * Travel times are calculated from each point to the remaining points passed into the function.
     * @param {TimeFilterSimple} body Simplified TimeFilterRequest type. Default search type is `departure`.
     */
    timeFilterFullMatrix: (body: TimeFilterSimple) => Promise<BatchResponse<TimeFilterResponse>[]>;
    timeFilterFast: (body: TimeFilterFastRequest) => Promise<TimeFilterFastResponse>;
    timeFilterFastBatch: (requests: TimeFilterFastRequest[]) => Promise<BatchResponse<TimeFilterFastResponse>[]>;
    /**
     * Generates a data frame (full matrix).
     * Travel times are calculated from each point to the remaining points passed into the function.
     * @param {TimeFilterFastSimple} body Simplified TimeFilterFastRequest type. Default search type is `departure`.
     */
    timeFilterFastFullMatrix: (body: TimeFilterFastSimple) => Promise<BatchResponse<TimeFilterFastResponse>[]>;
    /**
     * Simplified version of timeFilterFast.
     * Allows you to pass multiple coordinates with same params for matrixes to be made.
     * @param {TimeFilterFastSimple} body Simplified TimeFilterFastRequest. Default search type is `one_to_many`. Default properties are `['travel_time']`.
     */
    timeFilterFastSimple: (body: TimeFilterFastSimple) => Promise<TimeFilterFastResponse>;
    timeFilterPostcodeDistricts: (body: TimeFilterPostcodeDistrictsRequest) => Promise<TimeFilterPostcodeDistrictsResponse>;
    timeFilterPostcodeDistrictsBatch: (requests: TimeFilterPostcodeDistrictsRequest[]) => Promise<BatchResponse<TimeFilterPostcodeDistrictsResponse>[]>;
    timeFilterPostcodeSectors: (body: TimeFilterPostcodeSectorsRequest) => Promise<TimeFilterPostcodeSectorsResponse>;
    timeFilterPostcodeSectorsBatch: (requests: TimeFilterPostcodeSectorsRequest[]) => Promise<BatchResponse<TimeFilterPostcodeSectorsResponse>[]>;
    timeFilterPostcodes: (body: TimeFilterPostcodesRequest) => Promise<TimeFilterPostcodesResponse>;
    timeFilterPostcodesBatch: (requests: TimeFilterPostcodesRequest[]) => Promise<BatchResponse<TimeFilterPostcodesResponse>[]>;
    timeMap(body: TimeMapRequest): Promise<TimeMapResponse>;
    timeMap<T extends keyof TimeMapResponseType>(body: TimeMapRequest, format: T): Promise<TimeMapResponseType[T]>;
    timeMapBatch(bodies: TimeMapRequest[]): Promise<BatchResponse<Awaited<TimeMapResponse>>[]>;
    timeMapBatch<T extends keyof TimeMapResponseType>(bodies: TimeMapRequest[], format: T): Promise<BatchResponse<Awaited<TimeMapResponseType[T]>>[]>;
    /**
     * Simplified version of timeMap.
     * Allows you to pass multiple coordinates with same params for isochrones to be made.
     * @param {TimeMapSimple} body Simplified TimeMapRequest. Default search type is `departure`.
     * @param {keyof TimeMapResponseType} [format] Specify in which format response should be returned. Supported formats can be found - https://docs.traveltime.com/api/reference/isochrones#Response-Body
     */
    timeMapSimple(body: TimeMapSimple): Promise<TimeMapResponse>;
    timeMapSimple<T extends keyof TimeMapResponseType>(body: TimeMapSimple, format: T): Promise<TimeMapResponseType[T]>;
    timeMapFast(body: TimeMapFastRequest): Promise<TimeMapResponse>;
    timeMapFast<T extends keyof TimeMapFastResponseType>(body: TimeMapFastRequest, format: T): Promise<TimeMapFastResponseType[T]>;
    timeMapFastBatch(bodies: TimeMapFastRequest[]): Promise<BatchResponse<Awaited<TimeMapResponse>>[]>;
    timeMapFastBatch<T extends keyof TimeMapFastResponseType>(bodies: TimeMapFastRequest[], format: T): Promise<BatchResponse<Awaited<TimeMapFastResponseType[T]>>[]>;
    /**
     * Simplified version of timeMapFast.
     * Allows you to pass multiple coordinates with same params for isochrones to be made.
     * @param {TimeMapFastSimple} body Simplified TimeMapFastRequest. Default search type is `one_to_many`.
     * @param {keyof TimeMapResponseType} [format] Specify in which format response should be returned. Supported formats are same as in time map.
     */
    timeMapFastSimple(body: TimeMapFastSimple): Promise<TimeMapResponse>;
    timeMapFastSimple<T extends keyof TimeMapFastResponseType>(body: TimeMapFastSimple, format: T): Promise<TimeMapFastResponseType[T]>;
    getBaseURL: () => string | undefined;
    /**
     *
     * @param baseURL Set new base URL. Pass nothing to reset to default
     */
    setBaseURL: (baseURL?: string) => void;
    setRateLimitSettings: (settings: Partial<RateLimitSettings>) => void;
    setCredentials: (credentials: Credentials) => void;
}
