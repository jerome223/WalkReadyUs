"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TravelTimeClient = void 0;
const axios_1 = __importDefault(require("axios"));
const error_1 = require("../error");
const rateLimiter_1 = require("./rateLimiter");
const mapper_1 = require("./mapper");
const DEFAULT_BASE_URL = 'https://api.traveltimeapp.com/v4';
const sdkVersion = require('../../package.json').version;
function getHitAmountFromRequest(url, body) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    switch (url) {
        case '/time-filter':
        case '/routes':
        case '/time-filter/postcode-districts':
        case '/time-filter/postcode-sectors':
        case '/time-filter/postcodes': {
            return (((_a = body.departure_searches) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = body.arrival_searches) === null || _b === void 0 ? void 0 : _b.length) || 0);
        }
        case '/time-map/fast':
        case '/time-filter/fast': {
            return (((_c = body.arrival_searches.one_to_many) === null || _c === void 0 ? void 0 : _c.length) || 0) + (((_d = body.arrival_searches.many_to_one) === null || _d === void 0 ? void 0 : _d.length) || 0);
        }
        case '/distance-map':
        case '/time-map': {
            return (((_e = body.departure_searches) === null || _e === void 0 ? void 0 : _e.length) || 0) + (((_f = body.arrival_searches) === null || _f === void 0 ? void 0 : _f.length) || 0) + (((_g = body.unions) === null || _g === void 0 ? void 0 : _g.length) || 0) + (((_h = body.intersections) === null || _h === void 0 ? void 0 : _h.length) || 0);
        }
        default: return 0;
    }
}
function endpointChecksHPM(url) {
    return [
        '/time-filter',
        '/routes',
        '/time-filter/postcode-districts',
        '/time-filter/postcode-sectors',
        '/time-filter/postcodes',
        '/time-map/fast',
        '/time-filter/fast',
        '/time-map',
        '/distance-map',
    ].includes(url);
}
class TravelTimeClient {
    constructor(credentials, parameters) {
        var _a;
        this.geocodingBatch = (requests, req) => __awaiter(this, void 0, void 0, function* () { return this.batch((coords) => this.geocoding(coords, req), requests); });
        this.geocodingReverseBatch = (requests, acceptLanguage) => __awaiter(this, void 0, void 0, function* () { return this.batch((coords) => this.geocodingReverse(coords, acceptLanguage), requests); });
        this.mapInfo = () => __awaiter(this, void 0, void 0, function* () { return this.request('/map-info', 'get'); });
        this.routes = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/routes', 'post', { body }); });
        this.routesBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.routes, requests); });
        /**
         * Simplified version of routes.
         * Allows you to pass multiple coordinates with same params for routes to be made.
         * @param {RoutesSimple} body Simplified RoutesRequest type. Default search type is `departure`.
         */
        this.routesSimple = (body) => __awaiter(this, void 0, void 0, function* () { return this.routes((0, mapper_1.routesSimpleToRequest)(body)); });
        this.supportedLocations = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/supported-locations', 'post', { body }); });
        this.timeFilter = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter', 'post', { body }); });
        this.timeFilterBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.timeFilter, requests); });
        /**
         * Simplified version of timeFilter.
         * Allows you to pass multiple coordinates with same params for matrixes to be made.
         * @param {TimeFilterSimple} body Simplified TimeFilterRequest type. Default search type is `departure`.
         */
        this.timeFilterSimple = (body) => __awaiter(this, void 0, void 0, function* () { return this.timeFilter((0, mapper_1.timeFilterSimpleToRequest)(body)); });
        /**
         * Generates a data frame (full matrix).
         * Travel times are calculated from each point to the remaining points passed into the function.
         * @param {TimeFilterSimple} body Simplified TimeFilterRequest type. Default search type is `departure`.
         */
        this.timeFilterFullMatrix = (body) => __awaiter(this, void 0, void 0, function* () {
            const responses = yield this.timeFilterBatch((0, mapper_1.timeFilterSimpleToFullMatrix)(body));
            return (0, mapper_1.mergeTimeFilterResponses)(responses);
        });
        this.timeFilterFast = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter/fast', 'post', { body }); });
        this.timeFilterFastBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.timeFilterFast, requests); });
        /**
         * Generates a data frame (full matrix).
         * Travel times are calculated from each point to the remaining points passed into the function.
         * @param {TimeFilterFastSimple} body Simplified TimeFilterFastRequest type. Default search type is `departure`.
         */
        this.timeFilterFastFullMatrix = (body) => __awaiter(this, void 0, void 0, function* () {
            const responses = yield this.timeFilterFastBatch((0, mapper_1.timeFilterFastSimpleToFullMatrix)(body));
            return (0, mapper_1.mergeTimeFilterResponses)(responses);
        });
        /**
         * Simplified version of timeFilterFast.
         * Allows you to pass multiple coordinates with same params for matrixes to be made.
         * @param {TimeFilterFastSimple} body Simplified TimeFilterFastRequest. Default search type is `one_to_many`. Default properties are `['travel_time']`.
         */
        this.timeFilterFastSimple = (body) => __awaiter(this, void 0, void 0, function* () { return this.timeFilterFast((0, mapper_1.timeFilterFastSimpleToRequest)(body)); });
        this.timeFilterPostcodeDistricts = (body) => __awaiter(this, void 0, void 0, function* () {
            return this
                .request('/time-filter/postcode-districts', 'post', { body });
        });
        this.timeFilterPostcodeDistrictsBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.timeFilterPostcodeDistricts, requests); });
        this.timeFilterPostcodeSectors = (body) => __awaiter(this, void 0, void 0, function* () {
            return this
                .request('/time-filter/postcode-sectors', 'post', { body });
        });
        this.timeFilterPostcodeSectorsBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.timeFilterPostcodeSectors, requests); });
        this.timeFilterPostcodes = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter/postcodes', 'post', { body }); });
        this.timeFilterPostcodesBatch = (requests) => __awaiter(this, void 0, void 0, function* () { return this.batch(this.timeFilterPostcodes, requests); });
        this.getBaseURL = () => this.axiosInstance.defaults.baseURL;
        /**
         *
         * @param baseURL Set new base URL. Pass nothing to reset to default
         */
        this.setBaseURL = (baseURL = DEFAULT_BASE_URL) => {
            this.axiosInstance.defaults.baseURL = baseURL;
        };
        this.setRateLimitSettings = (settings) => {
            this.setRateLimitSettings(settings);
        };
        this.setCredentials = (credentials) => {
            this.apiKey = credentials.apiKey;
            this.applicationId = credentials.applicationId;
        };
        if (!(credentials.applicationId && credentials.apiKey))
            throw new Error('Credentials must be valid');
        this.applicationId = credentials.applicationId;
        this.apiKey = credentials.apiKey;
        this.rateLimiter = new rateLimiter_1.RateLimiter(parameters === null || parameters === void 0 ? void 0 : parameters.rateLimitSettings);
        this.axiosInstance = axios_1.default.create({
            baseURL: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.baseURL) !== null && _a !== void 0 ? _a : DEFAULT_BASE_URL,
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
            headers: {
                'Content-Type': 'application/json',
                'X-Application-Id': this.applicationId,
                'X-Api-Key': this.apiKey,
                'User-Agent': `Travel Time Nodejs SDK ${sdkVersion}`,
            },
        });
    }
    request(url, method, payload, retryCount = 0) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { body, config } = payload || {};
            const rq = () => (method === 'get' ? this.axiosInstance[method](url, config) : this.axiosInstance[method](url, body, config));
            try {
                const promise = (this.rateLimiter.isEnabled() && endpointChecksHPM(url)) ? new Promise((resolve) => {
                    this.rateLimiter.addAndExecute(() => resolve(rq()), getHitAmountFromRequest(url, body || {}), retryCount > 0);
                }) : rq();
                const { data } = yield promise;
                return data;
            }
            catch (error) {
                if (this.rateLimiter.isEnabled() && retryCount < this.rateLimiter.getRetryCount() && axios_1.default.isAxiosError(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
                    return new Promise((resolve) => {
                        this.rateLimiter.setIsSleeping(true);
                        setTimeout(() => {
                            this.rateLimiter.setIsSleeping(false);
                            resolve(this.request(url, method, payload, retryCount + 1));
                        }, this.rateLimiter.getTimeBetweenRetries());
                    });
                }
                throw error_1.TravelTimeError.makeError(error);
            }
        });
    }
    // eslint-disable-next-line class-methods-use-this
    batch(requestFn, bodies) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const chunkResults = yield Promise.allSettled(bodies.map((request) => requestFn(request)));
            chunkResults.forEach((chunkResult) => {
                if (chunkResult.status === 'rejected') {
                    results.push({ type: 'error', error: chunkResult.reason });
                }
                else {
                    results.push({ type: 'success', body: chunkResult.value });
                }
            });
            return results;
        });
    }
    distanceMap(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = format ? { Accept: format } : undefined;
            return this.request('/distance-map', 'post', { body, config: { headers } });
        });
    }
    distanceMapBatch(bodies, format) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batch((body) => this.distanceMap(body, format), bodies);
        });
    }
    distanceMapSimple(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = (0, mapper_1.distanceMapSimpleToRequest)(body);
            return this.distanceMap(request, format);
        });
    }
    geocoding(query, req) {
        return __awaiter(this, void 0, void 0, function* () {
            const { acceptLanguage, params } = req || {};
            const headers = acceptLanguage ? { 'Accept-Language': acceptLanguage } : undefined;
            const bounds = (params === null || params === void 0 ? void 0 : params.bounds) ? `${params.bounds.southEast.lat},${params.bounds.southEast.lng},${params.bounds.northWest.lat},${params.bounds.northWest.lng}` : undefined;
            const withinCountry = Array.isArray(params === null || params === void 0 ? void 0 : params['within.country']) ? params === null || params === void 0 ? void 0 : params['within.country'].join(',') : params === null || params === void 0 ? void 0 : params['within.country'];
            return this.request('/geocoding/search', 'get', {
                config: {
                    params: Object.assign(Object.assign({}, params), { 'within.country': withinCountry, bounds, query }),
                    headers,
                },
            });
        });
    }
    geocodingReverse(coords, acceptLanguage) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = acceptLanguage ? { 'Accept-Language': acceptLanguage } : undefined;
            return this.request('/geocoding/reverse', 'get', { config: { params: coords, headers } });
        });
    }
    timeMap(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = format ? { Accept: format } : undefined;
            return this.request('/time-map', 'post', { body, config: { headers } });
        });
    }
    timeMapBatch(bodies, format) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batch((body) => this.timeMap(body, format), bodies);
        });
    }
    timeMapSimple(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = (0, mapper_1.timeMapSimpleToRequest)(body);
            return this.timeMap(request, format);
        });
    }
    timeMapFast(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = format ? { Accept: format } : undefined;
            return this.request('/time-map/fast', 'post', { body, config: { headers } });
        });
    }
    timeMapFastBatch(bodies, format) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.batch((body) => this.timeMapFast(body, format), bodies);
        });
    }
    timeMapFastSimple(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = (0, mapper_1.timeMapFastSimpleToRequest)(body);
            return this.timeMapFast(request, format);
        });
    }
}
exports.TravelTimeClient = TravelTimeClient;
